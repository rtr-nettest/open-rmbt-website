/*******************************************************************************
 * Copyright 2015 Thomas Schreiber
 * Copyright 2013-2020 Rundfunk und Telekom Regulierungs-GmbH (RTR-GmbH)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

/* functions used on both /Verlauf and /Opentest */

var ODF = new Object();
ODF.json = null;
ODF.targetTable = null;
ODF.targetTableSummary = null;
ODF.hasHiddenRows = false;
/**
 * Generates the table row and appends it to the table set in ODF.targetTable
 * @param {Boolean} initiallyDisplayed true if the row is displayed from the beginning, false otherwise
 * @param {String} displayValue the value that will be displayed
 * @param {Language-Key} fieldname the key that is looked up in the i18n
 * @param {boolean} searchable if the field can be searched in open data
 * @param {String} searchneedle the value for which should be searched
*/
ODF.normalFormatter = function(initiallyDisplayed, displayValue, fieldname, searchable, searchneedle) {
        if (displayValue === null)
            return;
        
        var caption = Lang.getString(fieldname);
        if (searchable === undefined) {
            searchable = false;
        }
        if (searchneedle === undefined) {
            searchneedle = displayValue;
        }
        
        var formatting = "";
        if (initiallyDisplayed === false) {
            ODF.hasHiddenRows = true;
            formatting = " class=\"additional-information\" style=\"display:none\"";
        }
        
        var row = "<tr" + formatting + "><td class='uk-width-medium@s'>" + caption + "</td><td>";
        if (searchable === true) {
            row += "<a href='Opentests?" + fieldname + "=" + encodeURIComponent(searchneedle) + "'>" + displayValue + "<\/a> ";
        } 
        else {
            row += displayValue;
        }
        row += "</td></tr>";
        
        $(ODF.targetTable).append(row);
};
    
/**
 * Generates the table row and appends it to the table set in ODF.targetTableSummary
 * @param {String} displayValue the value that will be displayed
 * @param {Language-Key} fieldname the key that is looked up in the i18n
 * @param {type} classification value classification
 * @param {Language-Key} unit the key that will be looked up
 */
ODF.classificationFormatter = function(displayValue, fieldname, classification, unit) {
        if (displayValue === null)
            return;
        
        var caption = Lang.getString(fieldname);
        
        var row = "<tr><td class='uk-width-medium@s'>" + caption + "</td>";
        row += "<td >" + ODF.trafficLightFormatter(classification, false, fieldname) + " " + displayValue + "&nbsp;" + Lang.getString(unit) + "</td></tr>";
        $(ODF.targetTableSummary).append(row);
};

/**
 * Adds a row with a link that that shows all information that was previously hidden to
 * the table set in ODF.targetTable. 
 * If there is no hidden information available, this function does not do anything
 */
ODF.insertAdditionalInformationBreak = function() {
    //if there is nothing hidden -> return
    if (ODF.hasHiddenRows === false) {
        return;
    }
    var onClick = '$("' + ODF.targetTable + ' tr.additional-information").show();$(this).hide();return false;';
    var row = "<tr onclick='" + onClick + "'><td colspan='2'>";
    row += "<strong><a href='#' onclick='" + onClick + "'>" + Lang.getString("showAdditionalInformation") + "</a></strong>";
    row += "</tr></td>";
    $(ODF.targetTable).append(row);
};

/**
 * Gets the geoposition-string
 * @param {double} lat
 * @param {double} long
 * @param {String} loc_src
 * @param {double} loc_accuracy
 * @returns {String} the geoposition String e.g. N 48° 11.864' O 16° 20.475' (network, +/-56m)
 */
ODF.geopositionFormatter = function(lat, long, loc_src, loc_accuracy) {
        if (lat === null) 
            return null;
        var string = "";
        string += formatCoordinate(lat,Lang.getString('North'),Lang.getString('South')) + " ";
        string += formatCoordinate(long,Lang.getString('East'),Lang.getString('West')) + " ";
        var geostring = "(";
        if (loc_src !== null) {
            geostring += loc_src;
            if (loc_accuracy !== null) { geostring += ", "; }
        }
        if (loc_accuracy !== null) {
            geostring += "+/-" + Math.round(loc_accuracy) + "m";
        }
        geostring += ")";
        if (geostring !== "()")
            string += geostring;
        
        //make link to map position if all data is here
        if (loc_accuracy !== null) {
            var href = "Karte?lat=" + lat + "&long=" + long + "&accuracy=" + loc_accuracy + "&open_test_uuid=" + ODF.json.open_test_uuid;
            string = "<a href='" + href + "'>" + string + "</a>";
        }
        
        return string;
};

/**
 * Generates time string and search link
 * @param {Time} time
 * @returns {String}
 */
ODF.timeFormatter = function(time) {
    var day = formatOpenDataDateToLocalTime(time).substr(0, 10); //1234-67-90 23:56
    var time = formatOpenDataDateToLocalTime(time).substr(11);
    var beginDate = new Date(day.substr(0, 4), parseInt(day.substr(5, 2)) - 1, day.substr(8, 2), 0, 0, 0, 0);
    var endDate = new Date(day.substr(0, 4), parseInt(day.substr(5, 2)) - 1, day.substr(8, 2), 23, 59, 59, 0);
    var dateStringBegin = beginDate.getUTCFullYear() + "-" + pad(beginDate.getUTCMonth() + 1, 2) + "-" + pad(beginDate.getUTCDate(), 2) + " " + pad(beginDate.getUTCHours(), 2) + ":" + pad(beginDate.getUTCMinutes(), 2) + ":" + pad(beginDate.getUTCSeconds(), 2);
    var dateStringEnd = endDate.getUTCFullYear() + "-" + pad(endDate.getUTCMonth() + 1, 2) + "-" + pad(endDate.getUTCDate(), 2) + " " + pad(endDate.getUTCHours(), 2) + ":" + pad(endDate.getUTCMinutes(), 2)+ ":" + pad(endDate.getUTCSeconds(), 2);

    return "<a href='Opentests?time%5B%5D=%3E" + dateStringBegin + "&time%5B%5D=%3C" + dateStringEnd + "'>" + day + "<\/a> " + time;
};

/**
* Gets the traffic-light and traffic-light-link for a classification
 * @param {int} classification (0-3)
 * @param {boolean} qos use qos-link if true
 * @returns {String} the generated HTML-code */
ODF.trafficLightFormatter = function(classification, qos, field) {
    var sprite = null;
    if (classification >= 1 && classification <= 4) {
        sprite = 'svg-traffic-light-' + classification;
    }
    else {
        sprite = 'svg-empty';
    }

    return '<a href="https://www.netztest.at/redirect/' + selectedLanguage + '/' + ((qos !== undefined && qos) ? 'help_qos' : 'help_result') + '" target="_blank"><i class="svg-icon svg16 ' + sprite + '"></i></a>';
};

/**
 * Formats a bytes figure to one significant digit
 * @param {long} bytes
 * @returns {String} the formatted value
 */
ODF.bytesFormatter = function(bytes) {
    if (bytes === null)
        return null;
    var unit = Lang.getString('bytes');
    if (bytes > 1000) {
        bytes = bytes/1000;
        unit = Lang.getString('KB');        
    }
    if (bytes > 1000) {
        bytes = bytes/1000;
        unit = Lang.getString('MB');
    }
    return bytes.formatNumber(getSignificantDigits(bytes)) + "&nbsp;" + unit;
        
};

/**
 * Retrieves the localized value descripting for the roaming type
 * @param {Integer} roaming_type ranging from 0 to 2 as defined in the ControlServer
 * @returns {String} the representation of the value
 */
ODF.roamingFormatter = function(roaming_type) {
    if (roaming_type === null) {
        return null;
    }
    
    switch(roaming_type) {
        case 0:
            return Lang.getString('roaming_none');
        case 1:
            return Lang.getString('roaming_national');
        case 2:
            return Lang.getString('roaming_international');
    }
    return roaming_type;
};



/**
 * Wires up the already positioned images
 * @param {type} target
 * @param {type} openTestUUID
 */
function showShareBanner(target, openTestUUID) {
    //load images
    var domain = statisticProxy + "/" + statisticpath;
    //$(target + " img.forumlarge").attr("src", domain + "/de/" + openTestUUID + "/forumlarge.png");
    //$(target + " .forumlarge .htmlinput").val("<a href='https://" + document.domain + "/de/Opentest?" + openTestUUID + "'><img src='" + domain + "/de/" + openTestUUID + "/forumlarge.png' /></a>");
    //$(target + " .forumlarge .bbcinput").val("[url=https://" + document.domain + "/de/Opentest?" + openTestUUID + "][img]" + domain + "/de/" + openTestUUID + "/forumlarge.png[/img][/url]");
    //[url=https://www.bbcode.org/images/lubeck.jpg][img]https://www.bbcode.org/images/lubeck_small.jpg[/img][/url] 
    $(target + " img.forumsmall").attr("src",domain + "/" + selectedLanguage + "/" + openTestUUID + "/forumsmall.png");
    $(target + " .forumsmall .htmlinput").val("<a href='https://" + document.domain + "/" + selectedLanguage + "/Opentest?" + openTestUUID + "'><img src='" + domain + "/" + selectedLanguage + "/" + openTestUUID + "/forumsmall.png' /></a>");
    $(target + " .forumsmall .bbcinput").val("[url=https://" + document.domain + "/" + selectedLanguage + "/Opentest?" + openTestUUID + "][img]" + domain + "/" + selectedLanguage + "/" + openTestUUID + "/forumsmall.png[/img][/url]");
    $(target + " .forumbanner").toggle();
}

function triggerPdfDownload(openTestUuid, buttonIdentifier) {
    $(buttonIdentifier).attr("disabled","disabled");

    //create new form with open_test_uuid as param
    var form = $("<form></form>")
    form.attr("action",statisticProxy + "/" + statisticpath + "/export/pdf/" + selectedLanguage)
    form.attr("method","POST");
    form.append('<input type="hidden" name="open_test_uuid" value="' + openTestUuid + '" />')
    $("body").append(form);
    form.submit();
    setTimeout(function() {
        $(buttonIdentifier).removeAttr("disabled");
    }, 2000);
}

/**
 * Draws a ping "curve"
 * @param target
 * @param data
 */
function drawPingCurve(target, data) {
    //set width for flot
    $(target + " .speed-curve-graph-ping").css("width",$(target + " .speed-curve-graph-ping").width() + "px");
    var tableHtml = "";

    var nData = [];
    var firstTimeMs = data[0].time_elapsed;

    for (var i=0;i<data.length;i++) {
        nData.push([i + 1, data[i].ping_ms]);
        tableHtml += "<tr><td>" + (i+1) + "</td><td>" + ((data[i].time_elapsed - firstTimeMs)/1000).formatNumber(2) + " " + Lang.getString('seconds_abbreviation') + "</td>" +
            "<td>" + data[i].ping_ms.formatNumber(getSignificantDigits(data[i].ping_ms)) + " " + Lang.getString('ms') + "</td></tr>";
    }

    var placeholder = $(target + " .speed-curve-graph-ping");
    //draw the plot
    var plot = $.plot(placeholder, [{
        data: nData,
        color: color_for_speed_graph_upload,
        bars: {
            show: true,
            align: "center",
            barWidth: 0.25
        }
    }], {
        xaxis: {
                show: false,
        },
        yaxis: {
            tickFormatter: function(v,axis) {
                return Math.round(v * 1e3) / 1e3 + " " + Lang.getString("ms");
            }
        }
        }
    );

    $(target + " .speed-curve-table-ping").append(tableHtml);
}

/**
 * draws a speed curve in the given area
 * @param {css-selektor} target the target-area. the curve is drawn in the child with class ".speed-curve-graph"
 * @param {json} data
 * @param {string} phase either 'download' or 'upload'
 */
function drawSingleSpeedCurve(target, data, phase) {
    //set width for flot
    $(target + " .speed-curve-graph-" + phase).css("width",$(target + " .speed-curve-graph-" + phase).width() + "px");
    var tableHtml = "";

    //smoothing-factor for exponential smoothing
    var alpha = 0.7;
    var conAlpha = 1-alpha;
    var minInterval = 175; //minimal difference in ms between data points
    var noTransferThreshold = 1400; //ms for which no transfer has to take place to be drawn as a gap in the graph
      
    //get data points from json-response from the controlserver  
    var previousSpeed = data[0].bytes_total / Math.max(1, data[0].time_elapsed);
    var previousData = 0;
    var previousTime = 0;
    var dDownload = [];

    var maxSpeed = -1;
    
    //"preprocess" - if there are large gaps, fill them with artificial data points (#1117)
    var nData = [];
    for (var i=0;i<data.length;i++) {
        var timeDifference = data[i].time_elapsed - previousTime;
        if (timeDifference > (noTransferThreshold) && i > 0) {
            
            nData.push({
                time_elapsed: (data[i-1].time_elapsed + minInterval),
                bytes_total: (data[i-1].bytes_total)
            });
             nData.push({
                time_elapsed: (data[i-1].time_elapsed + 2*minInterval),
                bytes_total: (data[i-1].bytes_total)
            });
            nData.push({
                time_elapsed: (data[i].time_elapsed - minInterval),
                bytes_total: (data[i-1].bytes_total)
            });
        }
        nData.push(data[i]);
        previousTime = data[i].time_elapsed;
    }
    
    data = nData;
    previousTime = 0;
    
    for (var i = 0; i < data.length; ++i) {        
        var dataDifference = data[i].bytes_total - previousData;
        var timeDifference = data[i].time_elapsed - previousTime;
        
        //only one point every 250 ms or data is way too late (120 sek)
        if (timeDifference < minInterval || data[i].time_elapsed > 120000) {
            continue;
        }
        
        var speed = dataDifference / timeDifference;
        if (speed > 0) { //no interpolation in a gap
            speed = speed*alpha + previousSpeed*conAlpha;
        }
        previousSpeed = speed;
        previousData = data[i].bytes_total;
        previousTime = data[i].time_elapsed;
        //do it logarithmic
        speed = log10(speed/125); //bytes/s -> 
        dDownload.push([data[i].time_elapsed, speed,-2 ]); //byte : 128 = kilobit; mbit/sec = kbit/ms       //third parameter -2: fill until bottom of graph
        maxSpeed = Math.max(maxSpeed, speed);
        
        
        tableHtml += "<tr><td>" + (data[i].time_elapsed/1000).formatNumber(2) + " " + Lang.getString('seconds_abbreviation') + "</td>" +
                "<td>" + (dataDifference/timeDifference/125).formatNumber(getSignificantDigits(dataDifference/timeDifference/125)) + " " + Lang.getString('Mbps') + "</td>"+
                "<td>" + ODF.bytesFormatter(data[i].bytes_total) + "</td></tr>";
    }
    $(target + " .speed-curve-table-" + phase).append(tableHtml);
    tableHtml = "";
    
    
    var placeholder = $(target + " .speed-curve-graph-" + phase);

    //draw the plot
    var plot = $.plot(placeholder, [{
            data: dDownload,
            lines: {show: true, fill: true},
            color: (phase === "download")?color_for_speed_graph_download:color_for_speed_graph_upload
        }
    ], {
        xaxis: {
            show: true,
            tickFormatter: function(v, xaxis) {

                    return (v/1000).toFixed(1) + " s";
            }
        },
        yaxis: {
            show: true,
            tickFormatter: function(v,axis) {
                //inverse function to log from above
                v = ((Math.pow(10,v))); 
                //format <1mbps with 2 decimal points
                if (v>4) { return v.toFixed(0) + " " + Lang.getString('Mbps'); } else { return v.toFixed(1) + " " + Lang.getString('Mbps'); }
            },
            ticks: (maxSpeed > 3) ? [-1, 0, 1, 2, 3, 4] : [-1, 0, 1, 2, 3], //ln(125), ln(1250), ln(12500)
            min: -1
        }
    });

   
}

/**
 * Make the signal curve diagram
 * @param {selector} target
 * @param {json} data the opendata json-speed_curve-response
 * @param {number} beginDownload begin of the download phase in ms
 * @param {number} durationDownload duration of the download phase in ms
 * @param {number} beginUpload begin of the upload phase in ms
 * @param {number} durationUpload duration of the upload phase in ms
 */
function drawSignalCurve(target, data, beginDownload, durationDownload, beginUpload, durationUpload, beginPing, durationPing) {
    //nice test: O6ae80597-a64c-4bd3-a960-6c54ce348743 (develop)
    //different measurements: O474de928-7500-49c7-a9bc-65b7d73cfc99 (develop)
        
    //set width for flot
    $(target + " .signal-curve-graph").css("width",$(target + " .signal-curve-graph").width() + "px");

    //smoothing-factor for exponential smoothing
    //(more alpha, less smoothing)
    var alpha = 1;
    var conAlpha = 1-alpha;
    
    var previousSignal=(data.signal[0].lte_rsrp)?data.signal[0].lte_rsrp:data.signal[0].signal_strength;
    var previousTime= data.signal[0].time_elapsed;
    var previousNetworkType = "";
    var previousCatTechnology = "";
    var minSignal = 0;
    
    //timestamp and type of a now different signal
    var networkChanges = new Array();
    
    var tableHtml = "";
    var containsLTE = false;

    var dSignal = [];
    var prevCellInfo="";
    for (var i=0; i<data.signal.length; i++) {
        //ignore for now if null
        if (data.signal[i].lte_rsrp && data.signal[i].signal_strength === 0) {
            continue;
        }
        
        var time = data.signal[i].time_elapsed;
        
        //if new signal type -> remember!
        if (previousNetworkType !== data.signal[i].network_type) {
            //if we change from 3g to 4g or backwards -> do not interpolate
            if (previousCatTechnology !== data.signal[i].cat_technology) {
                previousCatTechnology = data.signal[i].cat_technology;
                dSignal.push([time, previousSignal]);
            }
            
            previousNetworkType = data.signal[i].network_type;
            networkChanges.push({time: time, network_type: previousNetworkType});
        }
        

        
        previousSignal = (data.signal[i].lte_rsrp)?data.signal[i].lte_rsrp:data.signal[i].signal_strength;
        previousTime = time;

        var addItem = function(value, abbr, title, searchParameter) {
            var ret = "";
            if (value) {
                if (searchParameter) {
                    ret = "<a href='Opentests?" + searchParameter + "=" + value + "'>" + value + "</a>";
                }
                else {
                    ret = value;
                }

                if (title) {
                    ret =  "<abbr title='" + title + "'>" + abbr + "</abbr>: " + ret + ", ";
                }
                else {
                    ret = abbr + ": " + value + ", ";
                }

            }

            return ret;
        };

        //explainatory line
        var makeCellInfo4G = function (ci) {
            var string = "4G: ";
            string += addItem(ci.ci, "CI", "Cell Identity", "cell_location_id");
            string += addItem(ci.tac, "TAC", "Tracking Area Code", "cell_area_code");
            string += addItem(ci.pci, "PCI", "Physical Cell Id");
            string += addItem(ci.earfcn, "EARFCN", "Evolved Absolute Radio Frequency Channel Number");
            if (ci.frequency_dl) {
                string += addItem(ci.frequency_dl + "&nbsp;MHz", "Freq", "Frequency (DL)");
            }
            string += addItem(ci.band, "Band");

            if (string.length > 0) {
                string = string.substr(0, string.length - 2);
            }
            return string;
        };

        var makeCellInfo3G = function (ci) {
            var string = "3G: ";
            string += addItem(ci.cid, "CID", " Cell Identity", "cell_location_id");
            string += addItem(ci.lac, "LAC", "Location Area Code", "cell_area_code");
            string += addItem(ci.psc, "PSC", "Primary Scrambling Code");
            string += addItem(ci.uarfcn, "UARFCN", " UTRA Absolute Radio Frequency Channel Number");
            if (ci.frequency_dl) {
                string += addItem(ci.frequency_dl + "&nbsp;MHz", "Freq", "Frequency (DL)");
            }
            string += addItem(ci.band, "Band");

            if (string.length > 0) {
                string = string.substr(0, string.length - 2);
            }
            return string;
        };

        var makeCellInfo2G = function (ci) {
            var string = "2G: ";
            string += addItem(ci.cid, "CID", " Cell Identity", "cell_location_id");
            string += addItem(ci.lac, "LAC", "Location Area Code", "cell_area_code");
            string += addItem(ci.bsic, "BSIC", "Base Station Identity Code");
            string += addItem(ci.arfcn, "ARFCN", "Absolute Radio Frequency Channel Number ");
            if (ci.frequency_dl) {
                string += addItem(ci.frequency_dl + "&nbsp;MHz", "Freq", "Frequency (DL)");
            }
            string += addItem(ci.band, "Band");

            if (string.length > 0) {
                string = string.substr(0, string.length - 2);
            }
            return string;
        };

        var makeCellInfo = function(signal) {
            if (signal.cell_info_4G) {
                return makeCellInfo4G(signal.cell_info_4G);
            }
            if (signal.cell_info_3G) {
                return makeCellInfo3G(signal.cell_info_3G);
            }
            if (signal.cell_info_2G) {
                return makeCellInfo2G(signal.cell_info_2G);
            }
            return "";
        };

        var signal = (data.signal[i].lte_rsrp)?data.signal[i].lte_rsrp:data.signal[i].signal_strength;
        var signalType = (data.signal[i].lte_rsrp)?Lang.getString('dBm'):Lang.getString('dBm');
        signal = signal*alpha + previousSignal*conAlpha;
        dSignal.push([time,signal]);

        if (signal < minSignal) {
            minSignal = signal;
        }

        var signalRow = "";
        if (signal) {
            signalRow += signal + " " + signalType;
        }
        if (data.signal[i].timing_advance !== null) {
            signalRow += signalRow !== "" ? ", " : "";
            signalRow += "<abbr title='" + Lang.getString("timing_advance") + "'>TA</abbr>: " + data.signal[i].timing_advance;
        }
        if (data.signal[i].lte_rsrq !== null) {
            signalRow += signalRow !== "" ? ", " : "";
            signalRow += "<abbr title='" + Lang.getString("referenced_signal_received_quality") + "'>RSRQ</abbr>: " + data.signal[i].lte_rsrq + " " + Lang.getString('dB')
        }

        tableHtml += "<tr><td>" + (data.signal[i].time_elapsed/1000).formatNumber(2) + "&thinsp;" + Lang.getString('seconds_abbreviation') + "</td>" +
            "<td>" + signalRow + "</td>" +
            "<td>" + data.signal[i].network_type + "</tr>";

        var cellInfo = makeCellInfo(data.signal[i]);
        if (cellInfo != prevCellInfo && cellInfo.trim().length > 0) {
            tableHtml += "<tr><td></td><td colspan='2'>" + cellInfo+ "</td></tr>"
            prevCellInfo = cellInfo;
        }

    }
    $(target + " .signal-curve-table").append(tableHtml);
    
    //set maximum at 20 sec
    if (previousTime<20000) {
        dSignal.push([20000,previousSignal]);
    }
    
        
    
    var markings = new Array();
    var markingsNetworkChange = new Array();
    
    //clone last signal in case that signal measurements were shorter than upload phase
    if (beginUpload !== null && ((beginUpload + durationUpload) > dSignal[dSignal.length-1][0])) {
        dSignal.push([(beginUpload + durationUpload),dSignal[dSignal.length-1][1]]);
    }
    
    //set markings for network type
    for (var i = 0;i<networkChanges.length;i++) {
        markingsNetworkChange.push({color: color_for_signal_graph, lineWidth: 1, xaxis: {from: networkChanges[i].time, to: networkChanges[i].time}});
        
        //background color for lte phases
        if (networkChanges[i].network_type === 'LTE' || networkChanges.network_type === 'LTE CA') {
            containsLTE = true;
            //if last one - draw to end of graph
            var end = dSignal[dSignal.length-1][0];
            if (i < (networkChanges.length-1)) {
                end = networkChanges[i+1].time;
            }
            markings.push({color: color_for_signal_graph_lte_background, xaxis: {from: networkChanges[i].time, to: end}});
            
            //change description to 'LTE/RTSP'
            networkChanges[i].network_type = 'LTE<br/>RSRP';
        }
    }
    
    //set markings for download phase
    if (beginDownload !== null) {
        markings.push({
            color: color_for_signal_graph_download_phase,
            xaxis: {
                from: beginDownload,
                to: beginDownload + durationDownload
            }
        });
    }

    //set markings for upload phase
    if (beginUpload !== null) {
        markings.push({
            color: color_for_signal_graph_upload_phase,
            xaxis: {
                from: beginUpload,
                to: beginUpload + durationUpload
            }
        });
    }

    //set markings for ping
    if (beginPing !== null) {
        markings.push({
            color: color_for_signal_graph_upload_phase,
            xaxis: {
                from: beginPing,
                to: beginPing + durationPing
            }
        });
    }
    
    markings = markings.concat(markingsNetworkChange);
    //markings.push(markingsNetworkChange);
    
    //invert everything to allow filling the graph from the "wrong" side
    minSignal = minSignal - (minSignal % 25) - 50;
    minSignal = Math.abs(minSignal);
    if (containsLTE)
        minSignal = Math.min(minSignal, 140);
    else
        minSignal = Math.min(minSignal, 120); //lower value for lte
    for (var i=0;i<dSignal.length;i++) {
        dSignal[i][1] = minSignal - Math.abs(dSignal[i][1]);
    }
    
    var placeholder = $(target + " .signal-curve-graph");
    //draw the plot
    var plot = $.plot(placeholder, [{
            data: dSignal,
            lines: {show: true, fill: true},
            color: color_for_signal_graph
        }
    ], {
        grid: {borderWidth: 1, markings: markings},
        xaxis: {
            show: true,
            min: 0,
            tickFormatter: function(v, xaxis) {
                return (v/1000).toFixed(1) +  "&nbsp;" + Lang.getString("seconds_abbreviation");
            }
        },
        yaxis: {
            show: true,
            max: minSignal-30,
            min: 0,
            tickFormatter: function(v,axis) {
                return (-(minSignal - v)); 
            }

        }
    });
    
    //add network types
    for (var i=0;i<networkChanges.length;i++) {
        var o = plot.pointOffset({x: networkChanges[i].time, y: -10});
        var type = networkChanges[i].network_type;
        var topOffset = (((i%2)===0)?10:20);
        placeholder.append("<div style='position:absolute;left:" + (o.left + 5) + "px;top:" + topOffset + "px;color:#666;font-size:smaller'>" + type +  "</div>");
    }
    
    //add download/upload
    if (beginDownload !== null) {
        o = plot.pointOffset({x: beginDownload, y: -10});
        placeholder.append("<div style='position:absolute;left:" + (o.left + 5) + "px;bottom:" + 20 + "px;color:#666;font-size:smaller'>" + Lang.getString("Download") + "</div>");
    }
    if (beginUpload !== null) {
        o = plot.pointOffset({x: beginUpload, y: -10});
        placeholder.append("<div style='position:absolute;left:" + (o.left + 5) + "px;bottom:" + 20 + "px;color:#666;font-size:smaller'>" + Lang.getString("Upload") + "</div>");
    }
    if (beginPing !== null) {
        o = plot.pointOffset({x: beginPing, y: -10});
        placeholder.append("<div style='position:absolute;left:" + (o.left) + "px;bottom:" + 33 + "px;color:#666;font-size:smaller'>" + Lang.getString("Ping") + "</div>");
    }
}


var useRTRTiles = true;
/**
 * Generate a map showing the given position
 * @param {String} target div
 * @param {float} lat
 * @param {float} long
 * @param {float} accuracy in meters
 * @param {JSON} positions past position for making a route
 * @param {float} distance distance that was travelled while conducting the test
 * @param {boolean} useBasemapAT if basemap.at maps should be used
 */
function setPosition(target, lat, long, accuracy, positions, distance, useBasemapAT) {
    
    //set source for map tiles
    var bases = new Array();

    if (useRTRTiles && !useBasemapAT) {
        bases.push(
            new ol.layer.Tile({
                source: new ol.source.OSM({
                    url: osm_server + '/{z}/{x}/{y}.png'
                }),
                title: 'OpenStreetMap',
                type: 'base',
                visible: true
            }));
    }

    if (useBasemapAT) {
        var gg = ol.proj.get('EPSG:4326');
        var sm = ol.proj.get('EPSG:3857');
        // basemap.at
        //taken from http://www.basemap.at/application/js/mobile-base3.js
        var templatepng =
            '{Layer}/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png';
        var urlsbmappng = [
            '//maps1.wien.gv.at/basemap/' + templatepng,
            '//maps2.wien.gv.at/basemap/' + templatepng,
            '//maps3.wien.gv.at/basemap/' + templatepng,
            '//maps4.wien.gv.at/basemap/' + templatepng
        ];
        var IS_CROSS_ORIGIN = 'anonymous';

        var tilegrid = new ol.tilegrid.WMTS({
            origin: [-20037508.3428, 20037508.3428],
            extent: [977650, 5838030, 1913530, 6281290],
            resolutions: [
                156543.03392811998, 78271.51696419998,
                39135.758481959994, 19567.879241008,
                9783.939620504, 4891.969810252,
                2445.984905126, 1222.9924525644,
                611.4962262807999, 305.74811314039994,
                152.87405657047998, 76.43702828523999,
                38.21851414248, 19.109257071295996,
                9.554628535647998, 4.777314267823999,
                2.3886571339119995, 1.1943285669559998,
                0.5971642834779999, 0.29858214174039993
            ],
            matrixIds: [
                '0', '1', '2', '3', '4', '5',
                '6', '7', '8', '9', '10',
                '11', '12', '13', '14', '15',
                '16', '17', '18', '19'
            ]
        });


        var bmap = new ol.source.WMTS({
            tilePixelRatio: 1,
            projection: sm,
            layer: 'geolandbasemap',
            /*layer: hiDPI ? 'bmaphidpi' : 'geolandbasemap',*/
            style: 'normal',
            matrixSet: 'google3857',
            urls: urlsbmappng,
            visible: true,
            //crossOrigin: IS_CROSS_ORIGIN,
            requestEncoding: /** @type {ol.source.WMTSRequestEncoding} */ ('REST'),
            tileGrid: tilegrid,
            attributions: [
                new ol.Attribution({
                    html: 'Tiles &copy; <a href="//www.basemap.at/">' +
                    'basemap.at</a> (STANDARD).'
                })
            ]
        });

        bases.push(new ol.layer.Tile({
            visible: true,
            preload: Infinity,
            source: bmap,
            title: 'Basemap.at',
            type: 'base'
        }));
    }
    //initialize map
    map = new ol.Map({
        layers: bases,
        controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
                collapsible: false
            })
        }).extend([
            new ol.control.ScaleLine()
        ]),
        target: $(target + " .test-map-container")[0],
        view: new ol.View({
            center: [0, 0],
            zoom: 2,
            maxZoom : 19
        }),
        interactions: ol.interaction.defaults({
            dragPan: false,
            mouseWheelZoom: false
        })
    });

    var getAdditionalLocationInfo = function(position) {
        if (position.loc_src && position.loc_src === 'gps') {
            var ret = "";
            if (position.altitude) {
                ret += Lang.getString("altitude") + ": " + (position.altitude).formatNumber(0) + "&nbsp;m";
            }
            if (position.bearing) {
                ret += (ret !== ""?", ":"");
                ret += Lang.getString("bearing") + ": " + (Math.round(position.bearing) % 360).formatNumber(0) + "°"
            }
            if (position.speed) {
                ret += (ret !== ""?", ":"");
                ret += Lang.getString("speed") + ": " + ((position.speed) * 3.6).formatNumber(0) + "&nbsp;km/h"
            }
            return ret;
        }
        return null;
    };

    //add table anyways if there are positions
    if (positions !== undefined && positions.length >= 1) {
        var tableHtml = "";
        for (var i=0;i<positions.length;i++) {
            tableHtml += "<tr>";
            tableHtml += "<td>" + (positions[i].time_elapsed/1000).formatNumber(2) + " " + Lang.getString('seconds_abbreviation') + "</td>"
            tableHtml += "<td>" + ODF.geopositionFormatter(positions[i].lat, positions[i].long, null, null) + "</td>";
            tableHtml += "<td>" + ((positions[i].loc_src) ? positions[i].loc_src + ", " : "") + "+/-" + Math.round(positions[i].loc_accuracy) + "m</td>";
            tableHtml += "</tr>";

            var additionalInfo = getAdditionalLocationInfo(positions[i]);
            if (additionalInfo) {
                tableHtml += "<tr><td></td><td colspan='2'>" + additionalInfo + "</td></tr>"
            }
        }

        $(target + " .location-curve-table").append(tableHtml);
    } else {
        $(target + " .location-curve-table").remove();
    }

    //if gps is contained - ignore network for drawing
    var containsGps = ($.grep(positions, function(p) {
        return p.loc_src === 'gps';
    }).length > 0);

    //add line to connect all positions, if more positions are given
    //but only if there is more than 1 position and there is a movement given
    // (this could not be the case if the accuracy was not good enough)
    if (positions !== undefined && positions.length > 1 && distance !== null && distance > 0) {
        var pointArray = [];

        //add all points to a point-array
        for (var i=0;i<positions.length;i++) {
            //calculate right position in meters (from degrees)
            pt = ol.proj.transform([positions[i].long, positions[i].lat],
                'EPSG:4326', 'EPSG:3857');

            //add to line, if accuracy is good enough
            //and it is gps - or gps does not exist
            if (positions[i].loc_accuracy < min_accuracy_for_showing_map &&
                (positions[i].loc_src === 'gps' || !containsGps)) {
                pointArray.push(pt);
            }
        }

        var line=new ol.geom.LineString(pointArray);
        //var line = new ol.geom.Point(pointArray[0]);

        var lineFeature = new ol.Feature({
            geometry: line
        });

        //styling
        var style = new ol.style.Style({
            stroke: new ol.style.Stroke({
                width: 5,
                color: color_for_map_movement,
                opacity: 0.9
            })
        });

        lineFeature.setStyle(style);

        //make vector
        var lineVectorLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: [lineFeature]
            })
        });

        //add to map
        map.addLayer(lineVectorLayer);
    }


    //calculate right position in meters (from degrees)
    pt = ol.proj.transform([long, lat],
        'EPSG:4326', 'EPSG:3857');

    //dynamic zoom level
    var zoomLevel = 11;
    var radius = 5000;
    if (accuracy !== null) {
        var totalAccuracy = accuracy + ((distance !== null) ? distance : 0);
        if (totalAccuracy < 100) {
            zoomLevel = 17;
            radius = 700;
        }
        else if (totalAccuracy < 1000) {
            zoomLevel = 13;
            radius = 2000;
        }
    }
    map.getView().setCenter(pt);
    map.getView().setZoom(zoomLevel);


    //set open data link
    var openDataLink = "Opentests?lat=%1&long=%2&radius=%3&loc_accuracy=%4#map-accordion"
        .replace("%1", lat)
        .replace("%2", long)
        .replace("%3", radius)
        .replace("%4", encodeURI("<" + radius));
    $(".open-data-radius-link").attr("href", openDataLink);

    //add marker with test position
    var iconStyle = new ol.style.Style({
        image: new ol.style.Icon({
            src: '../images/marker.png'
        })
    });

    var iconFeature = new ol.Feature({
        geometry: new ol.geom.Point(pt),
    });
    iconFeature.setStyle(iconStyle);

    var vectorSource = new ol.source.Vector({
        features: [iconFeature]
    });

    var vectorLayer = new ol.layer.Vector({
        source: vectorSource
    });


    map.addLayer(vectorLayer);

    //set coverage link
    $(".open-data-coverage-link").off("click");
    coverageDataLoaded = false;
    $(".open-data-coverage-link").on("click", function() {
        showCoverageData(long, lat);
    });
}

var cMap;
var coverageDataLoaded = false;
function showCoverageData(long, lat) {
    if (!coverageDataLoaded) {
        $.getJSON(statisticProxy + "/" + statisticpath + "/coverage",
            {
                lat: lat,
                long: long
            },
            function (data) {
                var resultTemplate = Handlebars.compile($("#coverageTemplate").html());
                data.location = ODF.geopositionFormatter(lat, long, null, null);
                //generate tables
                var generatedHtml = resultTemplate(data);
                $("#coverageModal").remove();
                $("#coverageTemplate").before(generatedHtml);
                coverageDataLoaded = true;

                //show in modal
                UIkit.modal($('#coverageModal')[0]).show()
                    .then(function () {
                        //load map, if any
                        if (data.coverages.length == 0) {
                            return;
                        }
                        var bases = []
                        bases.push(
                            new ol.layer.Tile({
                                source: new ol.source.OSM({
                                    url: osm_server + '/{z}/{x}/{y}.png'
                                }),
                                title: 'OpenStreetMap',
                                type: 'base',
                                visible: true
                            }));
                        //initialize map
                        cMap = new ol.Map({
                            layers: bases,
                            controls: ol.control.defaults({
                                attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
                                    collapsible: false
                                })
                            }).extend([
                                new ol.control.ScaleLine()
                            ]),
                            target: $("#coverageMap")[0],
                            view: new ol.View({
                                center: [0, 0],
                                zoom: 2,
                                maxZoom: 19//,
                                //projection: 'EPSG:4326'
                            }),
                            interactions: ol.interaction.defaults({
                                dragPan: true,
                                mouseWheelZoom: true
                            })
                        });

                        var geojsval = data.coverages[0].raster_geo_json;

                        var vectorSource = new ol.source.Vector({
                            features: [
                                new ol.Feature({
                                    geometry: new ol.format.GeoJSON().readGeometry(geojsval).transform('EPSG:4326', 'EPSG:3857')
                                })
                            ],

                        });

                        var vectorLayer = new ol.layer.Vector({
                            source: vectorSource
                            /*,style: new ol.style.Style ({
                                fill: new ol.style.Fill({
                                    color: 'rgba(255,100,50,0.5)'
                                })
                            })*/
                        })
                        cMap.addLayer(vectorLayer);

                        cMap.getView().fit(vectorSource.getExtent(), cMap.getSize());

                    });


            })


    } else {
        //show in modal
        UIkit.modal($('#coverageModal')[0]).show();
    }
}

/**
* Formats a number to 2 significant digits
* @param {double} number the number
* @return the formatted number
*/
function getSignificantDigits(number) { 
   if (number >= 10)  {
       return 0;
   } 
   else if (number >= 1) {
       return 1;
   }
   else if (number >= 0.1){
       return 2;
   }
   else if (number >= 0.01) {
       return 3;
   } 
   else {
       return 4;
   }
}

/**
 * Format a geo-coordinate (lat, lon) to the specified format (N 24° 12.123)
 * @param {double} decimal the Latitude or Longitude
 * @param {String} label_positive Label if the coordinate is positive (e.g. "N" for "North")
 * @param {String} label_negative Label if the coordinate is negative (e.g. "S" for "South")
 * @returns {String}
 */
function formatCoordinate(decimal, label_positive, label_negative) {
    var label = (decimal<0)?label_negative:label_positive;
    var deg = Math.floor(Math.abs(decimal));
    var tmp = Math.abs(decimal) - deg;
    var min = tmp*60;
    return label + " " + deg + "&deg; " + min.toFixed(3) + "'";
}

/**
 * Prints the given QoS-data into the given target
 * @param {JSON} testdata
 * @param {String} target
 */
function printQoSTestData(testdata, target) {
    "use strict";
    var tests = {};
    $.each(testdata.testresultdetail, function(index,value) {
        tests[value.uid] = value;
    });
    
    var testDesc = {};
    $.each(testdata.testresultdetail_desc, function(index, value) {
        if (testDesc[value.test] === undefined)  {
            testDesc[value.test] = [];
        }
        testDesc[value.test].push(value);
    });
    
    $.each(testdata.testresultdetail_testdesc,function(index,value) {
        var table = $(target + " .testresult-qos table");
        var clone = table.find(".prototype").clone().removeClass('prototype');
        var prototypeClone = clone.find(".qos-prototype").clone().removeClass('qos-prototype');
        
        clone.attr("id","qos" + value.test_type);
        clone.find('.qos-prototype').remove();

        
        var testsOK = 0;
        var testsTotal = 0;
        
        //@TODO: find out why this happens
        if (testDesc[value.test_type] === undefined) {
            console.log("Description for test type not found: " + value.test_type);
            return;
        }
        $.each(testDesc[value.test_type], function(i,overviews) {            
            //Fill in details
            
            $.each(overviews.uid, function(i, uid) {
                var test = tests[uid];
                
                //remove test uid since we have duplicate entries
                if (test === null) {
                    return;
                }
                //skip on mismatch (test.fail but success desc)
                if (test.failure_count !== 0 && overviews.status === 'ok' ||
                    test.failure_count === 0 && overviews.status === 'fail') {
                    return;
                }
                tests[uid] = null;
                
                testsTotal++;
                if (test.failure_count === 0) {
                    testsOK++;
                }
                
                prototypeClone.attr("id","qos" + uid);
                
                //Fill in details
                prototypeClone.find('.qos-description p').html(test.test_summary.replace(/ (\r\n|\n|\r)/gm,", ").replace(/(\r\n|\n|\r)/gm,", "));
                prototypeClone.find('.qos-description p').append(" - <a href='#'>" + Lang.getString('details') + "</a>");
                prototypeClone.find('.qos-classification').html(ODF.trafficLightFormatter((test.failure_count===0)?3:1,true));
                
                //Fill in details div
                prototypeClone.find('.qos-description strong.qos-success').html((test.failure_count===0)?Lang.getString("Successful"):Lang.getString("Failure"));
                prototypeClone.find('.qos-description p.qos-success').html(overviews.desc);
                prototypeClone.find('.qos-description p.qos-detail').html(test.test_desc.replace(/(\r\n|\n|\r)/gm,"<br>"));
                
                //wire up link
                prototypeClone.find('.qos-description p a').click(function() {
                    $('#qos' + uid + ' .qos-detail-div').toggle();
                    return false;
                });
                
                prototypeClone.clone(true).appendTo(clone);
            });
        });
        
        //Fill in details
        clone.find('td.description').html(value.desc);

        clone.find('.classification').html(ODF.trafficLightFormatter((testsTotal === testsOK)?3:1,true));
        
        clone.find(".detail").html(ODF.trafficLightFormatter((testsTotal === testsOK)?3:1,true) + " " + testsOK + "/" + testsTotal);
        clone.find('.caption').html(value.name);
        clone.find('.detail').append(' - <a href="#">' + Lang.getString('details') + '</a>');
        clone.find('.detail a').click(function() {
            $('#qos' + value.test_type + ' tr td.caption').parent().toggleClass("header-highlight");
            $('#qos' + value.test_type + ' tr').toggleClass("highlight");
            $('#qos' + value.test_type + ' tr.description').toggle();
            $('#qos' + value.test_type + ' tr.qos-singletest').toggle();
            return false;
        });
        
        clone.appendTo(table);
    });
    $(target + " .testresult-qos .prototype").remove();
}

//add formatting helper
Handlebars.registerHelper('kbpsToMbps', function (number) {
    if (typeof number === 'number') {
        var decimals = getSignificantDigits(number /1000);
        return (number/1000).formatNumber(decimals) + " " + Lang.getString("Mbps");
    }
});
